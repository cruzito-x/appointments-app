generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    Int               @id @default(autoincrement())
  name                  String
  email                 String            @unique
  password              String
  role                  String            @default("patient") @db.VarChar(20)
  createdAt             DateTime          @default(now()) @map("created_at")
  addresses             Address[]
  appointmentsAsPatient Appointment[]     @relation("PatientAppointments")
  appointmentsAsDoctor  Appointment[]     @relation("DoctorAppointments")
  messagesSent          Message[]         @relation("SenderMessages")
  messagesReceived      Message[]         @relation("ReceiverMessages")
  reviewsGiven          Review[]          @relation("PatientReviews")
  reviewsReceived       Review[]          @relation("DoctorReviews")
  medicalRecord         MedicalRecord?
  specialties           DoctorSpecialty[]
  availabilities        Availability[]
  notifications         Notification[]
}

model Address {
  id      Int    @id @default(autoincrement())
  userId  Int    @unique
  street  String
  city    String
  state   String
  zipCode String @map("zip_code")
  country String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Specialty {
  id      Int               @id @default(autoincrement())
  name    String            @unique
  doctors DoctorSpecialty[]
}

model DoctorSpecialty {
  doctorId    Int
  specialtyId Int
  doctor      User      @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  specialty   Specialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  @@id([doctorId, specialtyId])
}

model Appointment {
  id              Int      @id @default(autoincrement())
  patientId       Int
  doctorId        Int
  appointmentDate DateTime @map("appointment_date")
  status          String   @default("pending") @db.VarChar(20)
  createdAt       DateTime @default(now()) @map("created_at")

  patient User                 @relation("PatientAppointments", fields: [patientId], references: [id], onDelete: Cascade)
  doctor  User                 @relation("DoctorAppointments", fields: [doctorId], references: [id], onDelete: Cascade)
  history AppointmentHistory[]
  payment Payment?
}

model AppointmentHistory {
  id            Int         @id @default(autoincrement())
  appointmentId Int
  status        String      @db.VarChar(20)
  changedAt     DateTime    @default(now()) @map("changed_at")
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
}

model MedicalRecord {
  id          Int      @id @default(autoincrement())
  patientId   Int      @unique
  history     String?
  allergies   String?
  medications String?
  createdAt   DateTime @default(now()) @map("created_at")

  patient User @relation(fields: [patientId], references: [id], onDelete: Cascade)
}

model Payment {
  id            Int      @id @default(autoincrement())
  appointmentId Int      @unique
  amount        Float
  paymentDate   DateTime @default(now()) @map("payment_date")
  paymentStatus String   @default("pending") @db.VarChar(20)

  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
}

model Availability {
  id        Int      @id @default(autoincrement())
  doctorId  Int
  dayOfWeek String   @db.VarChar(10)
  startTime DateTime
  endTime   DateTime
  doctor    User     @relation(fields: [doctorId], references: [id], onDelete: Cascade)
}

model Review {
  id        Int      @id @default(autoincrement())
  patientId Int
  doctorId  Int
  rating    Int
  review    String?
  createdAt DateTime @default(now()) @map("created_at")

  patient User @relation("PatientReviews", fields: [patientId], references: [id], onDelete: Cascade)
  doctor  User @relation("DoctorReviews", fields: [doctorId], references: [id], onDelete: Cascade)
}

model Message {
  id         Int      @id @default(autoincrement())
  senderId   Int
  receiverId Int
  message    String
  sentAt     DateTime @default(now()) @map("sent_at")

  sender   User @relation("SenderMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReceiverMessages", fields: [receiverId], references: [id], onDelete: Cascade)
}

model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  message   String
  isRead    Boolean  @default(false) @map("is_read")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}
